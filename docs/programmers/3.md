# 문자열 섞기

## 첫번째 풀이

> 자바스크립트스러운 풀이는 이제 그만! 이건 코틀린이닷 ⭐️

```kotlin
class Solution {
    fun solution(str1: String, str2: String): String {
        var result = ""
        for (i in 0..<str1.length) {
            result += (str1[i] + str2[i])
        }
        return result
    }
}
```

이 코드는 우선 오류는 발생시킨다.

- `result += (str1[i] + str2[i])`

    - 자바스크립트에서는 문자열과 문자열의 결합은 문자열이다.
    - 코틀린에서는 글자 한개는 `Char` 라는 타입이 따로 존재한다. 하지만 문자와 문자의 연산은 문자를 유니코드로 변환하여 계산하고 `Int` 타입을 반환하게 된다.
      그래서 `Argument type mismatch: actual type is 'kotlin.Char', but 'kotlin.Int' was expected.` 에러가 발생하는 것이다. 즉 실제 타입은
      `Char` 인데 `Int` 타입이 기대되기 때문에 나오는 오류이다.
    -

- for문의 변화
    - `for (i in 0..str1.length - 1)` : 양끝의 숫자가 포함된 for 문이다. 가장 좋지 못한 syntax 라고 하는데, 처음에 이렇게 배운다.🥲
    - `for (i in 0 until str1.length)` : 0 <= until < str1.length 와 같은 의미로 마지막 수(끝 수)는 포함되지 않는다.
    - `for (i in str1.indices)`
        - `indices` :  리스트나 배열과 같은 컬렉션에서 사용할 수 있는 속성으로 컬렉션의 유효한 인덱스 범위를 나타내는 `IntRange` 객체를 반환한다. 문자열은 Char의 컬렉으로
          취급되기때문에 리스트나 배열과 유사하게 사용이 가능하다. 그래서 i는 인덱스 값으로 사용 가능하다.

## 두번째 풀이

> `StringBuilder` 를 사용한 풀이

```kotlin
class Solution {
    fun solution(str1: String, str2: String): String {
        val length = str1.length
        val sb = StringBuilder()
        for (i in 0 until length) {
            sb.append(str1[i]).append(str2[i])
        }
        return sb.toString()
    }
}
```

- `StringBuilder` 는 코틀린에서 문자열을 효율적으로 조작할 수 있도록 도와주는 클래스로서 문자열을 조작할 때마다 (문자열은 `immutable` 이기 때문에) 새로운 문자열 객체를 생성해야하는데, 이런
  경우 성능적으로 좋지않다. `StringBuilder`를 통하면 객체를 생성하지 않고 문자열을 조작할 수 있게 해준다.
- 간단한 코드 설명
    - for 문을 순회하면서 StringBuilder 를 통해서 문자열을 차례 차례 더해준다.(`append`) 여기서 최종 결과값은 문자열로 캐스팅해야한다. `StingBuiler`와 `String`은 타입이
      다른 것이기 때문!

## 세번째 풀이

> 다른 좋은 풀이들

### 람다식(람다표현식)

> 아래 두가지 풀이 모두 람다식을 사용한다. 람다표현식을 어떻게 사용하는지에 대해서 간단하게 알아보자.

- 기본문법

    ```markdown
        val lambdaName: (매개변수 타입) -> 반환 타입 = { 매개변수: 매개변수 타입 -> 함수 본문 }
    ```

    ```kotlin
        val sum: (Int, Int) -> Int = { a, b -> a + b }
    ```
    - 실제활용

  > 람다식은 다양하게 축약이 될 수 있어서 원래 식이 어떤 이유에 의해서 어떻게 축약되는지를 알면 좋을거 같아서 그 과정을 적어본다.

    ```kotlin
      val numbers = listOf(1, 2, 3, 4, 5)
      val doubled = numbers.map { it * 2 }
    ```
  위 식은 map 을 돌려서 각 요소에 2배를 하는 코드이다. 여기서 람다식은 `{ }` 부분인다. 이 부분이 어떻게 나오게 되는지 살펴보자.

    - 1단계 : 일반함수 정의
    ```kotlin
      fun double(x: Int): Int {
          return x * 2
      }
    ```
    - 2단계 : double 함수를 map 에 전달
    ```kotlin
       val doubled = numbers.map(::double)
    ```
    - 3단계 : double 함수를 익명함수로 전달이 가능하다.
    ```kotlin
        val doubled = numbers.map(fun(x: Int): Int {
            return x * 2
        })
    ```
    - 4단계 : 람다식에서 매개변수 타입과 반환 타입과 return 이 생략 가능하다.
    ```kotlin
        val doubled = numbers.map { x -> x * 2 }
    ```

### 1)

```kotlin
class Solution {
    fun solution(str1: String, str2: String) = str1.zip(str2).joinToString("") { (a, b) -> "$a$b" }
}
```

- `zip`

### 2)

```kotlin
class Solution {
    fun solution(str1: String, str2: String): String {
        return str1.indices.joinToString("") { "${str1[it]}${str2[it]}" }
    }
}
```

- ?? 🫠 위 코드는 `람다 표현식`을 사용한 코드라고 한다. 이런 경우 코드는 아는데 이해할 수 없다 라고 말할 수 있겠다. 한번 차근 차근 살펴보자.
